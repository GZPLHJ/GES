
	首先，通过XFBD数据集获取受损建筑物图片   
	对应----1.get specific damage object  image.py

    其次，同时删除检测到也无意义的极小目标
	（之所以无意义是因为极小目标本身不是人居住的房屋，甚至比一棵树还要小，这种库房类的目标的受损检测不仅对灾后地区受损程度的评估没有意义，它的存在还影响了模型检测其他目标）
极小目标（21*21=450、450稍微有点大）（18*18=324基本对应上能肉眼分辨的临界大小了）取200-300之间的，就是像素面积小于300的删除无论受损与否。
	对应----2.delete small object.py

	其次，通过k-means找到图像中的聚类中心位置
	对应----3.k-means get community center.py

	其次，通过逃逸算法更新聚类中心位置于建筑物的周边空旷区域
	对应----3.circle run_easy！！！use this.py

	××××××其次，删除处于任何目标框内的点(本意是为了消除仍然处于非受损建筑的点，但是对于特别密集的，他除了这种情况的点就没了，很不利于增强数据)
	对应----3. delete in label points.py

	其次，删除处于图像边缘的点
	对应----3. delete edge points.py

	其次，删除相连的点
	对应----3.delete connected points

	    注意：这里对于处于目标框边界的点不做处理，用于提供带有遮挡的受损建筑目标以保证模型的泛化性！！！

	其次，采取smote数据增强方法，在两个更新位置的中心插入新的点（目的：为在模拟真实地样本分部的基础上提供更多的样本）
	对应----4. smote.py

	其次，再删除处于任何目标框内的点以及相连的点
	对应----3. delete in label points.py
	对应----3.delete connected points

    其次，把严重受损和被摧毁建筑的目标的大中小小目标截取。
	对应----1.get specific damage object  image.py

	其次，再去更新插入点的信息，把这个点可以插入的图片的大小写进去，如果可以插入小目标则是s，如果可以插入的是中目标则是m，如果可以插入的是大目标则是l.
	对应----5. step1 updated points with sml .py

	其次，将上一步生成的每个点可以插入的大中小目标的标签文件，与已经截取好的图片（包括截取好的大中小的目标以及对应宽高的标签信息，1.get specific damage object  image.py即它的工作）合并，生成一个新的文件夹
	这个文件夹的标签，对应着train中存在可插入点的所有图片（即step1 updated points with sml .py生成的文件中不为0kb的txt文件），标签的格式改为：
	标签索引+x+y+w+h，由于每张图片可能会插入很多个目标图片，所以需要插入的目标图片的名字需要单独取名
	为了使得目标图片与之一一对应，另外在对应的images文件夹里存放所有这些目标图片并以他们的position即xy值为名字，这样就是独一无二的了。
	对应----6. step1 find augimages and get full information.py

	其次，将上一步生成的可直接插入的图片以及标签信息插入到原数据集中train集中。
	对应----6.step2 insert sml images.py

	最后，为了避免重采样，如果后加入的受损建筑的目标占据的任何一个非受损建筑目标的面积为s然后除以此非受损建筑目标本身的面积Sa，如果s/Sa大于0.5，则删除此非受损建筑目标的标签。
	对应----7. final.py





	其次，不再使用tomk-link或者enn这种欠采样的的机器学习方法进行数据增强了（这些欠采样都是处理列表数据这种的时候用，而且他们的目的是将不同类别的目标分割开，使得两类目标处于两个集群，以帮助模型更好的提取到不同类别目标的特征。但是由于受损建筑的目标本身就很少了更不可能存在集群的情况所以这些欠采样方法不能提供很好的作用，故舍弃）。

	最后，我们将图片插入后，判断是否存在于图片中任何一个不受损建筑物目标的重叠的情况，如果出现重叠的情况，那么，我们就删除与之重叠的非受损建筑物的目标。（目的：避免重采样，同时删除非受损建筑物的标签也可以一定程度上实现欠采样）
    对应----